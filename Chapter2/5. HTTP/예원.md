### 예상질문

```
1. HTTP/1.0, HTTP/2.0, HTTP/3.0의 특징을 설명해주세요.
2. HTTP/2를 설명하고 장점 두 가지를 설명하세요.
3. HTTP와 HTTPS의 차이를 설명해주세요.
4. SSL/TLS에 대해 설명해주세요.
5. SEO란 무엇이고, 관리 방법에 대해 설명해주세요.
6. HTTPS 구축 방법에 대해 설명해주세요.
```

---

# 2.5 HTTP

- 애플리케이션 계층으로 HTTP는 웹 서비스 통신에 사용된다.
- 현재는 HTTP/3 을 사용

## 2.5.1 HTTP/1.0

한 연결당 하나의 요청을 처리하도록 설계되었다. → RTT 증가

### RTT 증가

서버로부터 파일을 가져올 때마다 TCP의 3-way handshake를 계속 열어야 한다.<br/>
→ RTT 증가<br/>
→ 서버 부담 증가, 사용자 응답 시간 증가

```
* RTT (Round Trip Time, 왕복 시간)
-> 패킷이 목적지에 도달하고 나서 다시 출발지로 돌아오기까지 걸리는 시간. 즉, 패킷 왕복 시간
```

### RTT의 증가를 해결하기 위한 방법

- 이미지 스플리팅
  - 많은 이미지가 합쳐 있는 하나의 이미지를 다운 후 background-image의 position을 이용하여 이미지를 표기하는 방법
- 코드 압축
  - 코드를 압축해서 개행 문자, 빈칸을 없애서 코드의 크기를 최소화
- 이미지 Base64 인코딩
  - 이미지 파일은 64진법으로 이루어진 문자열로 인코딩
  - 장점: 서버와의 연결을 열고, 이미지에 대해 서버에 HTTP 요청을 할 필요가 없음
  - 단점: 문자열로 변환시 37% 정도 크기가 더 커짐

```
* 인코딩
- **정보의 형태나 형식**을 표준화, 보안, 처리 속도 향상, 저장 공간 절약 등을 위해 **다른 형태나 형식으로 변환**하는 처리 방식
```

## 2.5.2 HTTP/1.1

- 매번 TCP 연결을 하지 않고, 한 번 초기화를 한 이후에 `keep-alive` 라는 옵션으로 여러 개의 파일 송수신 가능
- 단점: 요청할 리소스 개수에 비례하여 대기시간 증가

### HOL Blocking(Head Of Line Blocking)

- 네트워크에서 같은 큐에 있는 패킷이 그 첫 번째 패킷에 의해 지연될 때 발생하는 성능 저하 현상

### 무거운 헤더 구조

- 헤더에 쿠키 등 많은 메타데이터가 들어 있고 압축이 되지 않아 무겁다

## 2.5.3 HTTP/2

> 멀티플렉싱, 헤더 압축, 서버 푸시, 요청의 우선순위 처리 를 지원하는 프로토콜 </br>
> HTTPS 위에서 동작

### 멀티 플렉싱

- 여러개의 스트림을 사용하여 송수신
- 특정 스트림의 패킷이 손실되어도 해당 스트림에만 영향을 미치고 나머지 스트림은 정상 동작
- 애플리케이션에서 받아온 메시지를 독립된 프레임으로 조각내어 서로 송수신한 이후 다시 조립하여 데이터를 주고 받음

```
* 스트림
- 시간이 지남에 따라 사용할 수 있게 되는 일련의 **데이터 요소를 가리키는** **데이터 흐름**
```

- HOL Blocking 해결 가능

### 헤더 압축

- 허프만 코딩 압축 알고리즘을 사용하는 HPACK 압축 형식

```html
* 허프만 코딩 - 문자열을 문자 단위로 쪼개 빈도수를 세어 빈도가 높은 정보는 적은
비트 수를, 빈도가 낮은 정보는 많은 비트 수를 사용하여 표현
```

### 서버 푸시

- 클라이언트 요청 없이 서버가 바로 리소스를 푸시할 수 있다.
  - ex) html을 읽으면서 그 안에 들어 있던 css 파일을 서버에서 푸시하여 클라이언트에게 줄 수 있다.
- (HTTP/1.1 에서는 클라이언트가 서버에 요청을 해야 파일을 다운로드 받을 수 있음)

## 2.5.4 HTTPS

`HTTPS`

- 애플리케이션 계층과 전송 계층 사이에 신뢰 계층인 SSL/TLS 계층을 넣은 신뢰할 수 있는 HTTP 요청을 말한다.

### SSL(Secure Socket Layer)/TLS(Transport Layer Security Protocol)

- SSL 1.0, SSL 2.0, SSL 3.0, TLS 1.0, TLS 1.3 까지 버전이 올라가며 마지막으로 TLS로 명칭이 변경
- 전송 계층에서 보안을 제공하는 프로토콜
- 클라이언트와 서버가 통신할 때 제3자가 메시지를 도청하거나 변조하지 못하도록 한다.
- 네트워크 상의 ‘인터셉터’ 방지
- **보안 세션**을 기반으로 데이터를 암호화하며 보안 세션이 만들어질 때 `인증 메커니즘`, `키 교환 암호화 알고리즘`, `해싱 알고리즘`이 사용됨

```
* 보안 세션
- 보안이 시작되고 끝나는 동안 유지되는 세션
- SSL/**TLS는 핸드셰이크**를 통해 보안 세션을 생성, 이를 기반으로 사태 정보 등을 공유

* 세션
- 운영체제가 어떠한 사용자로부터 자신의 **자산 이용을 허락하는 일정한 기간**
```

- TLS의 핸드셰이크
  → 1-RTT(키를 공유하고 인증, 인증 확인 등의 작업)가 생긴 후 데이터를 송수신
  → 클라이언트가 **사이퍼 슈트**를 서버에 전달하면 서버는 받은 사이퍼 슈트의 암호화 알고리즘 리스트를 제공할 수 있는지 확인
  → 제공할 수 있다면 서버에서 클라이언트로 인증서를 보내는 인증 메커니즘 시작
  → 해싱 알고리즘 등으로 암호화된 데이터의 송수신 시작
  ```
  * 사이퍼 슈트
  - 프로토콜, AEAD 사이퍼 모드, 해싱 알고리즘이 나열된 규약으로 5개가 있다.

  * AEAD 사이퍼 모드
  - 데이터 암호와 알고리즘
  ```
- 인증 메커니즘
  - CA에서 발급한 인증서를 기반으로 이루어진다.
  - CA에서 발급한 인증서는 안전한 연결을 시작하는데 있어 필요한 공개키를 클라이언트에게 제공하고, 신뢰할 수 있는 서버임을 보장
  - 인증서는 서비스 정보, 공개키, 지문, 디지털 서명 등으로 이루어짐
- CA 발급 과정
  - 자신의 사이트 정보와 공개키를 CA에 제출 → 공개키를 해시한 값인 지문을 사용하는 CA의 비밀키 등을 기반으로 CA 인증서 발급
  ```
  * 개인키
  - 비밀키라고도 하며, 개인이 소유하고 있는 키이자 반드시 자신만이 소유해야 하는 키

  * 공개키
  - 공개되어 있는 키
  ```
- 암호와 알고리즘
  - 키 교환 알고리즘으로는 대수곡선 기반의 ECDHE, 모듈식 기반의 DHE를 사용<br/>
    → 디피-헬만 키 교환 알고리즘 방식(y = g^x mod p)을 근간으로 만들어짐
- 해싱 알고리즘
  - 데이터를 추정하기 힘든 더 작고, 섞여 있는 조각으로 만드는 알고리즘
  - SSL/TLS 는 SHA-256, SHA-384 알고리즘을 사용
  ```
  * SHA-256 알고리즘
  - 해시 함수의 결과값이 256비트인 알고리즘
  - 비트 코인 등 많은 블록체인 시스템에서 사용
  - 해싱을 해야 할 메시지에 1을 추가하는 등 전처리를 하고 전처리된 메시지를 기반으로 해시를 반환

  * 해시
  - 다양한 길이를 가진 데이터를 고정된 길이를 가진 데이터로 매핑한 값
  ```

### SEO에도 도움이 되는 HTTPS

`SEO`

- 검색엔진 최적화
- 검색엔진으로 웹 사이트를 검색했을 때 그 결과를 페이지 상단에 노출시켜 많은 사람이 볼 수 있도록 최적화하는 방법

`SEO 관리 방법`

- 캐노니컬 설정
- 메타 설정
- 페이지 속도 개선
- 사이트 맵 관리

### HTTPS 구축 방법

1. 직접 CA에서 구매한 인증키를 기반으로 HTTPS 서비스 구축
2. 서버 앞단의 HTTPS를 제공하는 로드밸런서를 두기
3. 서버 앞단에 HTTPS를 제공하는 CDN 두기

## 2.5.5 HTTP/3

- HTTP/2 와의 차이점
  - HTTP/2 는 TCP 위에서 돌아가지만, HTTP/3은 QUIC이라는 계층 위에서 돌아간다.
  - TCP 기반이 아닌 UDP 기반으로 돌아간다.
- 장점
  - HTTP/2의 멀티플렉싱 가능
  - 초기 연결 설정 시 지연 시간 감소

### 초기 연결 설정시 지연 시간 감소

- QUIC은 TCP를 사용하지 않기 때문에 3-way handshake 과정 X
- 첫 연결 설정에 1-RTT만 소요
- 순방향 오류 수정 메커니즘 적용(FEC)
  - 전송한 패킷이 손실되었다면 수신 측에서 에러를 검출하고 수정하는 방식
  - 열악한 네트워크 환경에서도 낮은 패킷 손실률을 자랑
