### 예상질문

```
1. 라이브러리와 프레임워크의 차이에 대해 설명해주세요.
2. 디자인 패턴에 대해 설명해주세요.
3. 싱글톤 패턴과 그 장단점을 설명해주세요.
4. 옵저버 패턴을 어떻게 구현하나요?
5. 프록시 서버를 설명하고 사용 사례에 대해 설명해보세요.
6. 팩토리 패턴에 대해 설명해주세요.
7. CORS에 대해 설명해주세요.
8. MVC패턴에 대해 설명해주세요.
9. MVC패턴과 MVP패턴의 차이에 대해 설명해주세요.
10. MVC패턴과 MVVM패턴의 차이에 대해 설명해주세요.
```

---

> 라이브러리  
> -폴더명, 파일명 등에 대한 규칙이 없고 프레임워크에 비해 자유롭다.  
> 프레임워크  
> -폴더명, 파일명 등에 대한 규칙이 있으며 라이브러리에 비해 좀 더 엄격하다.

# 1.1 디자인 패턴

프로그램을 설계할 때 발생했던 문제점들을 객체 간의 상호 관계 등을 이용하여 해결할 수 있도록 하나의 '규약'형태로 만들어 놓은 것

## 1.1.1 싱글톤 패턴

하나의 클래스에 오직 하나의 인스턴스만 가지는 패턴

- 데이터베이스 연결 모듈에 많이 사용됨

### 장점

- 하나의 인스턴스를 만들어 놓고 해당 인스턴스를 다른 모듈들이 공유하며 사용하기 때문에 인스턴스를 생성할 때 드는 비용이 줄어듦

### 단점

- TDD(Test Driven Development)를 할 때 걸림돌이 됨. TDD를 할 때 단위 테스트를 주로 하는데, 단위 테스트는 테스트가 서로 독립적이어야 하며 테스트를 어떤 순서로든 실행할 수 있어야 함. 하지만 싱글톤 패턴은 각 테스트마다 `독립적인` 인스턴스를 만들기가 어려움.
- 의존성이 높아짐(모듈 간의 결합을 강하게 만듦).`의존성 주입(DI)`을 통해 해결 가능함.

#### 의존성 주입

- 모듈들을 쉽게 교체할 수 있는 구조가 되어 테스팅하기 쉽고 마이그레이션하기 수월함.
- 모듈들이 더욱더 분리되므로 클래스 수가 늘어나 복잡성이 증가될 수 있음.

## 1.1.2 팩토리 패턴

객체를 사용하는 코드에서 객체 생성 부분을 떼어내 추상화한 패턴이자 상속 관계에 있는 두 클래스에서 상위 클래스가 중요한 뼈대를 결정하고, 하위 클래스에서 객체 생성에 관한 구체적인 내용을 결정하는 패턴

- 상위 클래스와 하위 클래스가 분리되기 때문에 느슨한 결합을 가지며 상위 클래스에서는 인스턴스 생성 방식에 대해 전혀 알 필요가 없기 때문에 더 많은 유연성을 갖게 됨.
- 객체 생성 로직이 따로 떼어져 있어 코드를 리팩터링하더라도 한 곳만 고칠 수 있게 되니 유지 보수성이 증가됨.

## 1.1.3 전략 패턴

정책 패턴이라고도 하며, 객체의 행위를 바꾸고 싶은 경우 `직접` 수정하지 않고 전략이라고 부르는 `캡슐화한 알고리즘`을 컨텍스트 안에서 바꿔주면서 상호 교체가 가능하게 만드는 패턴

## 1.1.4 옵저버 패턴

주체가 어떤 객체(subject)의 상태 변화를 관찰하다가 상태 변화가 있을 때마다 메서드 등을 통해 옵저버 목록에 있는 옵저버들에게 변화를 알려주는 디자인 패턴

### 자바: 상속과 구현

#### 상속

- 자식 클래스가 부모 클래스의 메서드 등을 상속받아 사용하며 자식 클래스에서 추가 및 확장을 할 수 있는 것
- 이로 인해, 재사용성, 중복성의 최소화가 이루어짐

#### 구현

- 부모 인터페이스를 자식 클래스에서 재정의하여 구현하는 것
- 반드시 부모 클래스의 메서드를 재정의하여 구현해야 함

#### 상속과 구현 차이

- 상속은 일반 클래스, abstract 클래스를 기반으로 구현하며, 구현은 인터페이스를 기반으로 구현함

## 1.1.5 프록시 패턴

대상 객체(subject)에 접근하기 전 그 접근에 대한 흐름을 가로채 대상 객체 앞단의 인터페이스 역할을 하는 디자인 패턴

- 객체의 속성, 변환 등을 보완하며 보안, 데이터 검증, 캐싱, 로깅에 사용함.

### 프록시 서버

- 서버와 클라이언트 사이에서 클라이언트가 자신을 통해 다른 네트워크 서비스에 간접적으로 접속할 수 있게 해주는 컴퓨터 시스템이나 응용 프로그램

> CORS(Cross-Origin Resource Sharing)  
> : 서버가 웹 브라우저에 리소스를 로드할 때 다른 오리진을 통해 로드하지 못하게 하는 HTTP 헤더 기반 메커니즘
>
> - 프론트엔드 개발 시 프론트엔드 서버를 만들어서 백엔드 서버와 통신할 때 주로 CORS에러를 마주치는데, 이를 해결하기 위해 프론트엔드에서 프록시 서버를 만들기도 함

## 1.1.6 이터레이터 패턴

이터레이터(iterator)를 사용하여 컬렉션(collection)의 요소들에 접근하는 디자인 패턴

## 1.1.7 노출모듈 패턴

즉시 실행 함수를 통해 private, public과 같은 접근 제어자를 만드는 패턴

## 1.1.8 MVC 패턴

모델(Model), 뷰(View), 컨트롤러(Controller)로 이루어진 디자인 패턴

- 재사용성과 확장성이 용이함
- 애플리케이션이 복잡해질수록 모델과 뷰의 관계가 복잡해짐.

### 모델

- 애플리케이션의 데이터인 데이터베이스, 상수, 변수 등을 뜻함

### 뷰

- inputbox, checkbox, textarea 등 사용자 인터페이스 요소를 나타냄
- 모델을 기반으로 사용자가 볼 수 있는 화면
- 모델이 가지고 있는 정보를 따로 저장하지 않아야 하며, 단순히 사각형 모양 등 화면에 표시하는 정보만 가지고 있어야 함
- 변경이 일어나면 컨트롤러에 이를 전달해야 함

### 컨트롤러

- 하나 이상의 모델과 하나 이상의 뷰를 잇는 다리 역할을 하며 이벤트 등 메인 로직을 담당함
- 모델과 뷰의 생명주기도 관리하며, 모델이나 뷰의 변경 통지를 받으면 이를 해석하여 각각의 구성 요소에 해당 내용에 대해 알려줌

## 1.1.9 MVP 패턴

MVC 패턴으로부터 파생되었으며 MVC에서 C에 해당하는 컨트롤러가 프레젠터(presenter)로 교체된 패턴

- 뷰와 프레젠터는 일대일 관계이기 때문에 MVC 패턴보다 더 강한 결합을 지닌 디자인 패턴이라고 볼 수 있음

## 1.1.10 MVVM 패턴

MVC의 C에 해당하는 컨트롤러가 뷰모델(view model)로 바뀐 패턴

- 뷰모델은 뷰를 더 추상화한 계층이며, MVC 패턴과는 다르게 커맨드와 데이터 바인딩을 가지는 것이 특징임
